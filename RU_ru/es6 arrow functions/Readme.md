# Стрелочные функции (Arrow functions) в ECMAScript 6

![Arrow functions madness](http://habrastorage.org/files/555/5c8/ff8/5555c8ff81e74a9db0928264389eebdd.png "Arrow functions madness")

**Оглавление**

- [Синтаксис](#%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81)
    - [Один параметр](#%D0%9E%D0%B4%D0%B8%D0%BD-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80)
    - [Несколько параметров](#%D0%9D%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2)
    - [Без параметров](#%D0%91%D0%B5%D0%B7-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2)
    - [Традиционный синтаксис тела функции](#%D0%A2%D1%80%D0%B0%D0%B4%D0%B8%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9-%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81-%D1%82%D0%B5%D0%BB%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
    - [Литерал объекта](#%D0%9B%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0)
    - [Переменное число параметров](#%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5-%D1%87%D0%B8%D1%81%D0%BB%D0%BE-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2)
    - [Шаблон деструктуризации в качестве параметра](#%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%B2-%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B5-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B0)
- [Использование стрелочных функций](#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D1%85-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9)
    - [Установка контекста](#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0)
    - ["Прокидывание" контекста между несколькими вызовами](#%D0%9F%D1%80%D0%BE%D0%BA%D0%B8%D0%B4%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%B8%D0%BC%D0%B8-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0%D0%BC%D0%B8)
    - [Использование в качестве аргумента](#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B5-%D0%B0%D1%80%D0%B3%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0)
- [Другие особенности стрелочных функций](#%D0%94%D1%80%D1%83%D0%B3%D0%B8%D0%B5-%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D1%85-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9)
- [Итог](#%D0%98%D1%82%D0%BE%D0%B3)

_Примечание: Данная статья — это компиляция из вольного перевода статьи
[Understanding ECMAScript 6 arrow functions](http://www.nczonline.net/blog/2013/09/10/understanding-ecmascript-6-arrow-functions/)
и чтения последнего черновика [спецификации](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-arrow-function-definitions)
(January 20, 2014 Draft Rev 22)._

Одной из самых интересных частей нового стандарта ECMAScript 6 являются стрелочные функции.
Стрелочные функции, как и понятно из названия определяются новым синтаксисом, который использует стрелку `=>`.
Однако, помимо отличного синтаксиса, стрелочные функции отличаются от традиционных функций и в других моментах:
* Лексическое связывание. Значения _специальных переменных_ **this**, **super** и **arguments**  определяются не тем,
как стрелочные функции были вызваны, а тем, как они были созданы.
* Неизменяемые **this**, **super** и **arguments**. Значения этих переменных внутри стрелочных функций остаются неизменными
на протяжении всего жизненного цикла функции.
* Стрелочные функции не могут быть использованы как конструктор и кидают ошибку при использовании с оператором **new**.
* Недоступность «собственного» значения переменной **arguments**.

Было несколько причин для введения этих отличий. Первоочередная — это то, что связывание (binding) используется довольно
часто в JavaScript. Очень легко потерять нужное значение **this** при использовании традиционных функций, что может
привести к непредсказуемым последствиям. Другая причина, это то, что JS-движки смогут легко оптимизировать выполнение
стрелочных функций за счет этих ограничений (в противоположность традиционным функциям, которые могут быть использованы
в качестве конструктора и которые свободны для модификации _специальных переменных_).

## Синтаксис

В общем случае, синтаксис стрелочных функций выглядит так:
```javascript
var fun = (x) => x;
```
Он очень похож на аналогичный синтаксис в таких языках как Scala, CoffeeScript и на синтаксис lambda-выражений из C#.

Синтаксис стрелочных функций может быть различен, в зависимости от того, как вы объявляете функцию.
Объявление всегда начинается со списка аргументов, далее следует стрелка и тело функции.
И список аргументов, и тело функции могут иметь различную форму, в зависимости от того, что вы пишете.

### Один параметр

Объявление стрелочной функции, которая принимает один аргумент и просто возвращает его, выглядит очень просто:
```javascript
var reflect = value => value;
// эквивалент
var reflect = function(value) { return value; }
```

Когда у стрелочной функции только один аргумент, то он может быть объявлен без скобок. Следующее после стрелки тело функции
также может быть без фигурных скобок и может не содержать ключевого слова **return**.

### Несколько параметров

Но если вы хотите объявить более одного параметра, то должны обрамить список параметров в круглые скобки:
```javascript
var sum = (num1, num2) => num1 + num2;
// эквивалент
var sum = function(num1, num2) { return num1 + num2; };
```
Функция `sum` просто суммирует два аргумента. Единственное отличие от предыдущего примера в наличии круглых скобок и
запятой (прямо как в традиционных функциях).

### Без параметров

Аналогично, функция безо всяких аргументов, должна иметь пустой список параметров, заключённый в круглые скобки:
```javascript
var sum = () => 1 + 2;
// эквивалент
var sum = function() { return 1 + 2; };
```

### Традиционный синтаксис тела функции

Вы можете воспользоваться синтаксисом традиционных функций для тела стрелочной функции, когда оно содержит более
одного выражения. То есть обернуть функцию в фигурные скобки и добавить ключевое слово **return**:
```javascript
var sum = (num1, num2) => { return num1 + num2; }
// эквивалент
var sum = function(num1, num2) { return num1 + num2; };
```
Тело функции будет обработано точно так же, как и в случае классических функций, за исключением того, что значения
_специальных переменных_ **this**, **super** и **arguments** будут вычисляться по-другому.

### Литерал объекта

Отдельно надо упомянуть, что тело функции которое не содержит фигурных скобок и просто возвращает литерал объекта,
должно быть забрано в круглые скобки:
```javascript
var getTempItem = id => ({ id: id, name: "Temp" });
// эквивалент
var getTempItem = function(id) { return { id: id, name: "Temp" } };
```
Помещение литерала объекта в круглые скобки указывает парсеру, что фигурные скобки это не начало традиционного
синтаксиса для тела функции, а начало литерала.

### Переменное число параметров

Так как «собственный» объект **arguments** не доступен внутри стрелочной функции (значение **arguments** лексически
связано со значением **arguments** традиционной функции, внутри которой стрелочная функция была объявлена),
то для стрелочных функций с переменным числом параметров нужно использовать **rest**-паттерн из _шаблонов деструктуризации_.
Пример:
```javascript
var getTempItems = (...rest) => rest;
// эквивалент
var getTempItems = function() { return [].slice.apply(arguments) };
```

### Шаблон деструктуризации в качестве параметра

_В рамках данной статьи мы не рассматриваем шаблоны деструктуризации - вы можете почитать про них в статье
[Обзор ECMAScript 6, следующей версии JavaScript](http://habrahabr.ru/post/175371/), хотя эта информация частично устарела._

Как видно из предыдущего примера, несмотря на то, что у стрелочной функции всего один аргумент, всё равно необходимо применять круглые
скобки при использовании _шаблонов деструктуризации_ как единственного параметра функции.
Примеры с другими _шаблонами_:
```javascript
var a = ({a}) => a;
var b = ([b]) => b;
```

## Использование стрелочных функций

### Установка контекста

Одним из частых сценариев в JavaScript является установка правильного значения **this** внутри функции (связывание).
Поскольку значение **this** может быть изменено, то, в зависимости от контекста исполнения функции, возможно ошибочно
воздействовать на один объект, когда вы имели ввиду совершенно другой. Посмотрите на следующий пример:
```javascript
var pageHandler = {
    id: "123456"
    , init: function() {
        document.addEventListener("click", function(event) {
            this.doSomething(event.type);     // ошибка
        });
    }
    , doSomething: function(type) { console.log("Handling " + type  + " for " + this.id) }
};
```
В приведённом коде объект `pageHandler` должен обрабатывать клики на странице. Метод `init()` навешивает обработчик
на нужное событие, который внутри себя вызывает `this.doSomething()`. Однако код отработает неправильно. Ссылка на
`this.doSomething()` не валидна, поскольку **this** указывает на объект `document` внутри обработчика события вместо
планируемого `pageHandler`. При попытке выполнить этот код, вы получите ошибку, поскольку объект `document` не имеет
метода `doSomething`.

Вы можете завязать значение **this** на объекте `pageHandler` используя `handleEvent` или вызвав у функции стандартный
метод `bind()`:
```javascript
var pageHandler = {
    id: "123456"
    , init: function() {
        document.addEventListener("click", (function(event) {
            this.doSomething(event.type);     // error
        }).bind(this));
    }
    , doSomething: function(type) { console.log("Handling " + type  + " for " + this.id) }
};
```
Теперь код работает так, как и задумывалось, но выглядит более громоздко. Кроме того, вызывая `bind(this)`
вы каждый раз создаёте новую функцию, значение **this** которой завязано на значении `pageHandler`, но зато код работает
так, как вы задумывали.

Стрелочные функции решают проблему более элегантным способом, поскольку используют лексическое связывание значения
**this** (а также **super** и **arguments**) и его значение определяется значением **this** в том месте, где стрелочная функция
была создана. Например:
```javascript
var pageHandler = {
    id: "123456"
    , init: function() {
        document.addEventListener("click", event => this.doSomething(event.type));
    }
    , doSomething: function(type) { console.log("Handling " + type  + " for " + this.id) }
};
```
В этом примере обработчик это стрелочная функция в которой вызывается `this.doSomething()`. Значение **this** будет тем
же, что и в функции `init()`, и код в данном примере отработает правильно, аналогично тому, который использовал `bind()`.
Вне зависимости от того, возвращает вызов `this.doSomething()` значение или нет, выражение внутри тела стрелочной
функции не нужно обрамлять в фигурные скобки.

Кроме того, пример выше ещё и эффективнее вызова `bind()`, потому что для браузера он аналогичен следующему коду:
```javascript
var pageHandler = {
    id: "123456"
    , init: function() {
		var self = this;
        document.addEventListener("click", function(event) {
			return self.doSomething(event.type)
		});
    }
    , doSomething: function(type) { console.log("Handling " + type  + " for " + this.id) }
};
```
То есть не происходит создание новой функции, как в случае с вызовом `bind()`.

### «Прокидывание» контекста между несколькими вызовами

Очевидно, что можно вкладывать одну стрелочную функцию в другую, тем самым «прокидывая» значение **this** через них:
```javascript
var obj = {
	arr1: [1, 2, 3]
	, arr2: ['a', 'b', 'c']
	, concatenate: function(a, b){ return a + "|" + b }
	, intersection: function() {
		return this.arr1.reduce( (sum, v1) => // arrow function 1
			this.arr2.reduce( (sum, v2) => { // arrow function 2
				sum.push( this.concatenate( v1, v2 ) )
				return sum;
			}
			, sum )
		, [] )
	}
};
var arrSum = obj.intersection();//['1|a', '1|b', '1|c', '2|a', '2|b', '2|c', '3|a', '3|b', '3|c']
```

### Использование в качестве аргумента

Короткий синтаксис стрелочных функций делает их идеальными кандидатами на передачу в качестве аргументов в вызов других
функций. Например, если вы хотите отсортировать массив, то обычно пишете что-то типа такого:
```javascript
var result = values.sort(function(a, b) { return a - b });
```
Довольно многословно для простой операции. Сравните с короткой записью стрелочной функции:
```javascript
var result = values.sort((a, b) => a - b);
```
Использование таких методов, как массивные `sort()`, `map()`, `reduce()` и так далее, может быть упрощено с использованием
короткого синтаксиса стрелочной функции.

## Другие особенности стрелочных функций

Несмотря на то, что стрелочные функции отличаются от традиционных функций, у них есть общие черты:
* Оператор `typeof` вернёт `"function"` для стрелочной функции
* Стрелочная функция также экземпляр «класса» Function, поэтому `instanceof` сработает так же как, и с традиционной функцией
* Вы всё ещё можете использовать методы `call()`, `apply()`, и `bind()`, однако помните, что они не будут влиять на
значение **this**
* Вы можете использовать метод `toMethod()`, однако он не будет менять значение **super**
(_метод `toMethod()` введён в es6 и не рассматривается в рамках данной статьи_).

Существенным отличием от традиционных функций является то, что попытка вызвать стрелочную функцию с указанием оператора
**new** вызовет ошибку исполнения.

## Итог

Стрелочные функции это одно из интереснейших нововведений в ECMAScript 6, которое, имея краткий синтаксис определения,
упростит передачу функций в качестве значения параметра другой функции.

Лаконичный синтаксис позволит писать сложные вещи ~~ещё сложнее~~проще. Например, так будет выглядеть генератор идентификаторов
(который на es5 выглядит [куда многословней](http://google.github.io/traceur-compiler/demo/repl.html#var%20idGen%20%3D%20(start%20%3D%200%2C%20id%20%3D%20start%2C%20reset%20%3D%20(newId%20%3D%20start)%20%3D%3E%20id%20%3D%20newId%2C%20next%20%3D%20()%20%3D%3E%20id%2B%2B)%20%3D%3E%0A%09(%7Breset%2C%20next%7D)%3B%0A%0Avar%20gen%20%3D%20idGen(100)%3B%0Aconsole.log(gen.next()%2C%20gen.next()%2C%20gen.reset(10)%2C%20gen.next())%3B%2F%2F100%20101%2010%2010)
):
```javascript
let idGen = (start = 0, id = start, reset = (newId = start) => id = newId, next = () => id++) =>
	({reset, next});

let gen = idGen(100);
console.log(gen.next(), gen.next(), gen.reset(10), gen.next());//100 101 10 10
```
А лексическое связывание закроет один из самых больших источников боли и разочарования для разработчиков, а так же
улучшит производительность за счёт оптимизации на уровне js-движка.

![Madness in FF](http://habrastorage.org/files/5c2/f4a/9e2/5c2f4a9e241148508eb78557063afb46.png "Madness in FF")

Если вы хотите попробовать стрелочные функции, то можете выполнить вышеуказанные примеры в консоли Firefox, который на данный
момент (02.2014 FF28) почти полноценно поддерживает стрелочные функции (FF28 неправильно вычисляет значение **arguments**).

Также вы можете попробовать стрелочные функции и другие возможности es6 в
[онлайн трансляторе Traceur](http://google.github.io/traceur-compiler/demo/repl.html).
